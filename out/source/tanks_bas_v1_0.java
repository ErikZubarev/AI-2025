/* autogenerated by Processing revision 1293 on 2024-03-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class tanks_bas_v1_0 extends PApplet {

// Följande kan användas som bas inför uppgiften.
// Syftet är att sammanställa alla varabelvärden i scenariet.
// Variabelnamn har satts för att försöka överensstämma med exempelkoden.
// Klassen Tank är minimal och skickas mer med som koncept(anrop/states/vektorer).

boolean left, right, up, down;
boolean mouse_pressed;

PImage tree_img;
PVector tree1_pos, tree2_pos, tree3_pos;

Tree[] allTrees   = new Tree[3];
Tank[] allTanks   = new Tank[6];

// Team0
int team0Color;
PVector team0_tank0_startpos;
PVector team0_tank1_startpos;
PVector team0_tank2_startpos;
Tank tank0, tank1, tank2;

// Team1
int team1Color;
PVector team1_tank0_startpos;
PVector team1_tank1_startpos;
PVector team1_tank2_startpos;
Tank tank3, tank4, tank5;

int tank_size;

boolean gameOver;
boolean pause;

//======================================
public void setup() 
{
  /* size commented out by preprocessor */;
  up             = false;
  down           = false;
  mouse_pressed  = false;
  
  gameOver       = false;
  pause          = true;
  
  // Trad
  tree_img = loadImage("tree01_v2.png");
  tree1_pos = new PVector(230, 600);
  tree2_pos = new PVector(280, 230);
  tree3_pos = new PVector(530, 520);
  
  tank_size = 50;
  
  // Team0
  team0Color  = color(204, 50, 50);             // Base Team 0(red)
  team0_tank0_startpos  = new PVector(50, 50);
  team0_tank1_startpos  = new PVector(50, 150);
  team0_tank2_startpos  = new PVector(50, 250);
  
  // Team1
  team1Color  = color(0, 150, 200);             // Base Team 1(blue)
  team1_tank0_startpos  = new PVector(width-50, height-250);
  team1_tank1_startpos  = new PVector(width-50, height-150);
  team1_tank2_startpos  = new PVector(width-50, height-50);
  
  //tank0_startpos = new PVector(50, 50);
  tank0 = new Tank("tank0", team0_tank0_startpos,tank_size, team0Color );
  tank1 = new Tank("tank1", team0_tank1_startpos,tank_size, team0Color );
  tank2 = new Tank("tank2", team0_tank2_startpos,tank_size, team0Color );
  
  tank3 = new Tank("tank3", team1_tank0_startpos,tank_size, team1Color );
  tank4 = new Tank("tank4", team1_tank1_startpos,tank_size, team1Color );
  tank5 = new Tank("tank5", team1_tank2_startpos,tank_size, team1Color );
  
  allTanks[0] = tank0;                         // Symbol samma som index!
  allTanks[1] = tank1;
  allTanks[2] = tank2;
  allTanks[3] = tank3;
  allTanks[4] = tank4;
  allTanks[5] = tank5;
}

public void draw()
{
  background(200);
  checkForInput(); // Kontrollera inmatning.
  
  if (!gameOver && !pause) {
    
    // UPDATE LOGIC
    updateTanksLogic();
    
    // CHECK FOR COLLISIONS
    checkForCollisions();
  
  }
  
  // UPDATE DISPLAY 
  displayHomeBase();
  displayTrees();
  displayTanks();  
  
  displayGUI();
}

//======================================
public void checkForInput() {
  
      if (up) {
        if (!pause && !gameOver) {
          tank0.state=1; // moveForward
        }
      } else 
      if (down) {
        if (!pause && !gameOver) {
          tank0.state=2; // moveBackward
        }
      }
      
      if (right) {
      } else 
      if (left) {
      }
      
      if (!up && !down) {
        tank0.state=0;
      }
}

//======================================
public void updateTanksLogic() {
  for (Tank tank : allTanks) {
    tank.update();
  }
}

public void checkForCollisions() {
  //println("*** checkForCollisions()");
  for (Tank tank : allTanks) {
    tank.checkForCollisions(tank1);
    tank.checkForCollisions(new PVector(width, height));
  }
}

//======================================
// Följande bör ligga i klassen Team
public void displayHomeBase() {
  strokeWeight(1);

  fill(team0Color, 15);    // Base Team 0(red)
  rect(0, 0, 150, 350);
  
  fill(team1Color, 15);    // Base Team 1(blue) 
  rect(width - 151, height - 351, 150, 350);
}
  
// Följande bör ligga i klassen Tree
public void displayTrees() {
  imageMode(CENTER);
  image(tree_img, tree1_pos.x, tree1_pos.y);
  image(tree_img, tree2_pos.x, tree2_pos.y);
  image(tree_img, tree3_pos.x, tree3_pos.y);
  imageMode(CORNER);
}

public void displayTanks() {
  for (Tank tank : allTanks) {
    tank.display();
  }
}

public void displayGUI() {
  if (pause) {
    textSize(36);
    fill(30);
    text("...Paused! (\'p\'-continues)\n(upp/ner-change velocity)", width/1.7f-100, height/2.5f);
  }
  
  if (gameOver) {
    textSize(36);
    fill(30);
    text("Game Over!", width/2-100, height/2);
  }  
}

//======================================
public void keyPressed() {
  System.out.println("keyPressed!");

    if (key == CODED) {
      switch(keyCode) {
      case LEFT:
        left = true;
        break;
      case RIGHT:
        right = true;
        break;
      case UP:
        up = true;
        break;
      case DOWN:
        down = true;
        break;
      }
    }

}

public void keyReleased() {
  System.out.println("keyReleased!");
    if (key == CODED) {
      switch(keyCode) {
      case LEFT:
        left = false;
        break;
      case RIGHT:
        right = false;
        break;
      case UP:
        up = false;
        //tank0.stopMoving();
        break;
      case DOWN:
        down = false;
        //tank0.stopMoving();
        break;
      }
      
    }
    
    if (key == 'p') {
      pause = !pause;
    }
}

// Mousebuttons
public void mousePressed() {
  println("---------------------------------------------------------");
  println("*** mousePressed() - Musknappen har tryckts ned.");
  
  mouse_pressed = true;
  
}
class Sprite {
  
}
class Tank extends Sprite {

  PVector acceleration;
  PVector velocity;
  PVector position;
  
  PVector startpos;
  String name;
  PImage img;
  int col;
  float diameter;

  float speed;
  float maxspeed;
  
  int state;
  boolean isInTransition;
 
  //======================================  
  Tank(String _name, PVector _startpos, float _size, int _col ) {
    println("*** Tank.Tank()");
    this.name         = _name;
    this.diameter     = _size;
    this.col          = _col;

    this.startpos     = new PVector(_startpos.x, _startpos.y);
    this.position     = new PVector(this.startpos.x, this.startpos.y);
    this.velocity     = new PVector(0, 0);
    this.acceleration = new PVector(0, 0);
    
    this.state        = 0; //0(still), 1(moving)
    this.speed        = 0;
    this.maxspeed     = 3;
    this.isInTransition = false;
  }
  
  //======================================
  public void checkEnvironment() {
    println("*** Tank.checkEnvironment()");
    
    borders();
  }
  
  public void checkForCollisions(Sprite sprite) {
    
  }
  
  public void checkForCollisions(PVector vec) {
    checkEnvironment();
  }
  
  // Följande är bara ett exempel
  public void borders() {
    float r = diameter/2;
    if (position.x < -r) position.x = width+r;
    if (position.y < -r) position.y = height+r;
    if (position.x > width+r) position.x = -r;
    if (position.y > height+r) position.y = -r;
  }
  
  
  //======================================
  public void moveForward(){
    println("*** Tank.moveForward()");
    
    if (this.velocity.x < this.maxspeed) {
      this.velocity.x += 0.01f;
    } else {
      this.velocity.x = this.maxspeed;  
    }
  }
  
  public void moveBackward(){
    println("*** Tank.moveBackward()");
    
    if (this.velocity.x > -this.maxspeed) {
      this.velocity.x -= 0.01f;
    } else {
      this.velocity.x = -this.maxspeed;  
    }
  }
  
  public void stopMoving(){
    println("*** Tank.stopMoving()");
    
    // hade varit finare med animering!
    this.velocity.x = 0; 
  }
  
  //======================================
  public void action(String _action) {
    println("*** Tank.action()");
    
    switch (_action) {
      case "move":
        moveForward();
        break;
      case "reverse":  
        moveBackward();
        break;
      case "turning":
        break;
      case "stop": 
        stopMoving();
        break;
    }
  }
  
  //======================================
  //Här är det tänkt att agenten har möjlighet till egna val. 
  
  public void update() {
    println("*** Tank.update()");
    
    switch (state) {
      case 0:
        // still/idle
        action("stop");
        break;
      case 1:
        action("move");
        break;
      case 2:
        action("reverse");
        
        break;
    }
    
    this.position.add(velocity);
  }
  
  //====================================== 
  public void drawTank(float x, float y) {
    fill(this.col, 50); 

    ellipse(x, y, 50, 50);
    strokeWeight(1);
    line(x, y, x+25, y);
    
    //kanontornet
    ellipse(0, 0, 25, 25);
    strokeWeight(3);   
    float cannon_length = this.diameter/2;
    line(0, 0, cannon_length, 0);
  }
  
  public void display() {
    fill(this.col);
    strokeWeight(1);
    
    pushMatrix();
    
      translate(this.position.x, this.position.y);
      
      imageMode(CENTER);
      drawTank(0, 0);
      imageMode(CORNER);
      
      strokeWeight(1);
      fill(230);
      rect(0+25, 0-25, 100, 40);
      fill(30);
      textSize(15);
      text(this.name +"\n( " + this.position.x + ", " + this.position.y + " )", 25+5, -5-5);
    
    popMatrix();
  }
}
class Team {
  
  
  // Används inte, men bör ligga här. 
  public void displayHomeBase() {
  }
  
  public void display() {
    displayHomeBase();
  }
}
class Tree extends Sprite {
  
  PVector position;
  String  name; 
  PImage  img;
  float   diameter;
  
  //**************************************************
  Tree(PImage _image, int _posx, int _posy) {
    
    this.img       = _image;
    this.diameter  = this.img.width/2;
    this.name      = "tree";
    this.position  = new PVector(_posx, _posy);
    
  }

  //**************************************************
  
  public void checkCollision() {
    
  }

  //**************************************************  
  public void display() {
      
  }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "tanks_bas_v1_0" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
